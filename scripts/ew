#!/usr/bin/env python

from ConfigParser import ConfigParser
from copy import copy
from datetime import datetime, timedelta
from enginewrangler import Wrangler
from enginewrangler.valuetypes import *
from optparse import OptionParser
from os import getcwd, makedirs, path

CONFIG_FILENAME = path.join(getcwd(), 'ew.cfg')
OUTPUT_DIR = path.join(getcwd(), 'output')
EPOCH = datetime(1970, 1, 1, 0, 0, 0)
DEFAULTS = {
    'host': 'localhost',
    'port': 3306,
    'database': '',
    'username': 'mysql',
    'password': 'mysql',
    'prefix': 'exp_',
    'site': 'default_site',
    'format': 'xml',
    'split_channels': False
}

def main():
    defaults = copy(DEFAULTS)

    if path.exists(CONFIG_FILENAME):
        config = ConfigParser()
        config.read(CONFIG_FILENAME)

        defaults.update(
            dict(
                config.items('Engine Wrangler')
            )
        )

    parser = OptionParser()
    parser.add_option(
        '-o', '--host',
        dest = 'host',
        help = 'MySQL host',
        default = defaults.get('host')
    )

    parser.add_option(
        '-p', '--port',
        dest = 'port',
        type = 'int',
        help = 'MySQL port',
        default = defaults.get('port')
    )

    parser.add_option(
        '-u', '--user',
        dest = 'username',
        help = 'MySQL username',
        default = defaults.get('username')
    )

    parser.add_option(
        '-w', '--password',
        dest = 'password',
        help = 'MySQL password',
        default = defaults.get('password')
    )

    parser.add_option(
        '-d', '--database',
        dest = 'database',
        help = 'MySQL database name',
        default = defaults.get('database')
    )

    parser.add_option(
        '-r', '--prefix',
        dest = 'prefix',
        help = 'ExpressionEngine table prefix',
        default = defaults.get('prefix')
    )

    parser.add_option(
        '-s', '--site',
        dest = 'site',
        help = 'ExpressionEngine site name',
        default = defaults.get('site')
    )

    parser.add_option(
        '-f', '--format',
        dest = 'format',
        help = 'Output file format',
        default = defaults.get('format')
    )

    parser.add_option(
        '-l', '--split',
        dest = 'split_channels',
        help = 'Split output by content type',
        action = 'store_true',
        default = defaults.get('split') in ('true', 'yes', '1', True, 1)
    )

    parser.add_option(
        '-m', '--imgpath',
        dest = 'image_path',
        help = 'Path to store images',
        default = defaults.get('imgpath')
    )

    parser.add_option(
        '-n', '--imgdomain',
        dest = 'image_domain',
        help = 'Domain for images',
        default = defaults.get('imgdomain')
    )

    parser.add_option(
        '-a', '--newbase',
        dest = 'new_base',
        help = 'Replace domains in image URLs with this string',
        default = defaults.get('newbase')
    )

    options, args = parser.parse_args()
    wrangler = Wrangler(
        host = options.host,
        port = options.port,
        username = options.username,
        password = options.password,
        database = options.database,
        prefix = options.prefix,
        format = options.format
    )

    has_split = False
    wrangler.select_site(options.site)

    if not options.split_channels:
        wrangler._start_split()
        has_split = True
        wrangler.describe_site()
    else:
        if not path.exists(OUTPUT_DIR):
            makedirs(OUTPUT_DIR)

        wrangler._start_split(
            open(
                path.join(
                    OUTPUT_DIR,
                    'index.%s' % options.format
                ),
                'w'
            )
        )

        wrangler.describe_site()
        wrangler._end_split()

    for channel in wrangler.get_channels():
        if options.split_channels:
            wrangler._start_split(
                open(
                    path.join(
                        OUTPUT_DIR,
                        '%s.%s' % (channel['channel_name'], options.format)
                    ),
                    'w'
                )
            )

            has_split = True
        else:
            wrangler.describe(channel, 'channel',
                ('name', 'title', 'description'),
                end = False,
                section_name = 'section',
                aliases = {
                    'name': 'slug',
                    'title': 'name'
                }
            )

        for title in wrangler.get_titles(
            channel['channel_id'],
            status = 'open'
        ):
            wrangler.describe(title, 'title',
                ('title',),
                end = False,
                aliases = {
                    'url_title': 'slug',
                    'id': 'title_id'
                },
                transformers = {
                    'sticky': lambda v: v == 'y',
                    'author_id': lambda v: (
                        'author',
                        dict(
                            wrangler._prepare(
                                wrangler.get_author(v),
                                'member',
                                (
                                    'username',
                                ),
                                transformers = {
                                    'last_activity': lambda v: EPOCH + timedelta(
                                        seconds = v
                                    )
                                }
                            ),
                            **wrangler._prepare(
                                wrangler._pivot(
                                    'member_fields',
                                    'member_data',
                                    'm',
                                    member_id = v
                                ),
                                'member'
                            )
                        )
                    ),
                    'entry_date': lambda v: (
                        'date',
                        EPOCH + timedelta(seconds = v)
                    )
                },
                section_name = 'item'
            )

            for key, value in wrangler._pivot(
                'channel_fields',
                'channel_data',
                channel_id = channel['channel_id'],
                entry_id = title['entry_id']
            ).items():
                if (
                    key.endswith('_content') or \
                    key.endswith('_body') or \
                    key.endswith('_text') or \
                    key in ('content', 'body', 'text')
                ):
                    if options.image_path:
                        value = wrangler.parse_for_images(
                            value,
                            options.image_path,
                            options.image_domain,
                            options.new_base
                        )

                    wrangler._formatter.property(key, HtmlString(value))
                else:
                    wrangler._formatter.property(key, value)

            categories = wrangler.get_title_categories(
                title['entry_id']
            )

            if any(categories):
                wrangler._formatter.start_section('categories')
                for category in categories:
                    wrangler._formatter.property('category', category['name'])

                wrangler._formatter.end_section()

            wrangler.tidy(1)

        if options.split_channels:
            wrangler._end_split()
            has_split = False
        else:
            wrangler.tidy(1)

    if not options.split_channels:
        wrangler._end_split()
        has_split = True

if __name__ == "__main__":
    main()
